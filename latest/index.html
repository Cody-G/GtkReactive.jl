<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · GtkReactive</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="../versions.js"></script></head><body><nav class="toc"><h1>GtkReactive</h1><form class="search" action="search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">Introduction</a><ul class="internal"><li><a class="toctext" href="#Scope-of-this-package-1">Scope of this package</a></li><li><a class="toctext" href="#Concepts-1">Concepts</a></li><li><a class="toctext" href="#A-first-example-1">A first example</a></li><li><a class="toctext" href="#Drawing-and-canvas-interaction-1">Drawing and canvas interaction</a></li></ul></li><li><a class="toctext" href="reference.html">Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">Introduction</a></li></ul><a class="edit-page" href="https://github.com/JuliaGizmos/GtkReactive.jl/tree/08d7964cc633e16c983341bdb3dffe6ee2a4ff90/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Introduction-1" href="#Introduction-1">Introduction</a></h1><h2><a class="nav-anchor" id="Scope-of-this-package-1" href="#Scope-of-this-package-1">Scope of this package</a></h2><p>GtkReactive is a package building on the functionality of <a href="https://github.com/JuliaGraphics/Gtk.jl">Gtk.jl</a> and <a href="https://github.com/JuliaGizmos/Reactive.jl">Reactive.jl</a>. Its main purpose is to simplify the handling of interactions among components of a graphical user interface (GUI).</p><p>Creating a GUI generally involves some or all of the following:</p><ol><li><p>creating the controls</p></li><li><p>arranging the controls (layout) in one or more windows</p></li><li><p>specifying the interactions among components of the GUI</p></li><li><p>(for graphical applications) canvas drawing</p></li><li><p>(for graphical applicaitons) canvas interaction (mouse clicks, drags, etc.)</p></li></ol><p>GtkReactive is targeted primarily at items 1, 3, and 5. Layout is handled by Gtk.jl, and drawing (with a couple of exceptions) is handled by plotting packages or at a lower level by <a href="https://github.com/JuliaGraphics/Cairo.jl">Cairo</a>.</p><p>GtkReactive is suitable for:</p><ul><li><p>&quot;quick and dirty&quot; applications which you might create from the command line</p></li><li><p>more sophisticated GUIs where layout is specified using tools like <a href="https://glade.gnome.org/">Glade</a></p></li></ul><p>For usage with Glade, the <a href="reference.html#Input-widgets-1">Input widgets</a> and <a href="reference.html#Output-widgets-1">Output widgets</a> defined by this package allow you to supply a pre-existing <code>widget</code> (which you might load with GtkBuilder) rather than creating one from scratch. Users interested in using GtkReactive with Glade are encouraged to see how the <a href="reference.html#GtkReactive.player"><code>player</code></a> widget is constructed (see <code>src/extrawidgets.jl</code>).</p><p>At present, GtkReactive supports only a small subset of the <a href="https://developer.gnome.org/gtk3/stable/ch03.html">widgets provided by Gtk</a>. It is fairly straightforward to add new ones, and pull requests would be welcome.</p><h2><a class="nav-anchor" id="Concepts-1" href="#Concepts-1">Concepts</a></h2><p>The central concept of Reactive.jl is the <code>Signal</code>, a type that allows updating with new values that then triggers actions that may update other <code>Signal</code>s or execute functions. Your GUI ends up being represented as a &quot;graph&quot; of Signals that collectively propagate the state of your GUI. GtkReactive couples <code>Signal</code>s to Gtk.jl&#39;s widgets. In essense, Reactive.jl allows ordinary Julia objects to become the triggers for callback actions; the primary advantage of using Julia objects, rather than Gtk widgets, as the &quot;application logic&quot; triggers is that it simplifies reasoning about the GUI and seems to reduce the number of times ones needs to consult the <a href="https://developer.gnome.org/gtk3/stable/gtkobjects.html">Gtk documentation</a>.</p><p>It&#39;s worth emphasizing two core Reactive.jl features:</p><ul><li><p>updates to <code>Signal</code>s are asynchronous, so values will not propagate until the next time the Reactive message-handler runs</p></li><li><p>derived signals are subject to garbage-collection; you should either hold a reference to or <code>preserve</code> any derived signals</p></li></ul><p>Please see the <a href="http://juliagizmos.github.io/Reactive.jl/">Reactive.jl documentation</a> for more information.</p><h2><a class="nav-anchor" id="A-first-example-1" href="#A-first-example-1">A first example</a></h2><p>Let&#39;s create a <code>slider</code> object:</p><pre><code class="language-jlcon">julia&gt; using Gtk.ShortNames, GtkReactive

julia&gt; sl = slider(1:11)
Gtk.GtkScaleLeaf with Signal{Int64}(6, nactions=1)

julia&gt; typeof(sl)
GtkReactive.Slider{Int64}</code></pre><p>A <code>GtkReactive.Slider</code> holds two important objects: a <code>Signal</code> (encoding the &quot;state&quot; of the widget) and a <code>GtkWidget</code> (which controls the on-screen display). We can extract both of these components:</p><pre><code class="language-jlcon">julia&gt; signal(sl)
Signal{Int64}(6, nactions=1)

julia&gt; typeof(widget(sl))
Gtk.GtkScaleLeaf</code></pre><p>(If you omitted the <code>typeof</code>, you&#39;d instead see a long display that encodes the settings of the <code>GtkScaleLeaf</code> widget.)</p><p>At present, this slider is not affiliated with any window. Let&#39;s create one and add the slider to the window. We&#39;ll put it inside a <code>Box</code> so that we can later add more things to this GUI:</p><pre><code class="language-jlcon">julia&gt; win = Window(&quot;Testing&quot;) |&gt; (bx = Box(:v));  # a window containing a vertical Box for layout

julia&gt; push!(bx, sl);    # put the slider in the box

julia&gt; showall(win);</code></pre><p>Because of the <code>showall</code>, you should now see a window with your slider in it:</p><p><img src="assets/slider1.png" alt="slider1"/></p><p>The value should be 6, set to the median of the range <code>1:11</code> that we used to create <code>sl</code>. Now drag the slider all the way to the right, and then see what happened to <code>sl</code>:</p><pre><code class="language-">push!(sl, 11)
Reactive.run_till_now()
sleep(1)
Reactive.run_till_now()</code></pre><pre><code class="language-jlcon">julia&gt; sl
Gtk.GtkScaleLeaf with Signal{Int64}(11, nactions=1)</code></pre><p>You can see that dragging the slider caused the value of the signal to update. Let&#39;s do the converse, and set the value of the slider programmatically:</p><pre><code class="language-jlcon">julia&gt; push!(sl, 1)</code></pre><p>Now if you check the window, you&#39;ll see that the slider is at 1.</p><p>Realistic GUIs may have many different widgets. Let&#39;s add a second way to adjust the value of that signal, by allowing the user to type a value into a textbox:</p><pre><code class="language-jlcon">julia&gt; tb = textbox(Int; signal=signal(sl))
Gtk.GtkEntryLeaf with Signal{Int64}(1, nactions=2)

julia&gt; push!(bx, tb);

julia&gt; showall(win);</code></pre><p><img src="assets/slider2.png" alt="slider2"/></p><p>Here we created the textbox in a way that shared the signal of <code>sl</code> with the textbox; consequently, the textbox updates when you move the slider, and the slider moves when you enter a new value into the textbox. <code>push!</code>ing a value to <code>signal(sl)</code> updates both.</p><h2><a class="nav-anchor" id="Drawing-and-canvas-interaction-1" href="#Drawing-and-canvas-interaction-1">Drawing and canvas interaction</a></h2><p>Aside from widgets, GtkReactive also adds canvas interactions, specifically handling of mouse clicks and scroll events. It also provides high-level functions to make it easier implement rubber-banding, pan, and zoom functionality.</p><p>To illustrate these tools, let&#39;s first open a window with a drawing canvas:</p><pre><code class="language-jlcon">julia&gt; using Gtk.ShortNames, GtkReactive, TestImages

julia&gt; win = Window(&quot;Image&quot;);

julia&gt; c = canvas(UserUnit);

julia&gt; push!(win, c);</code></pre><p>The <code>UserUnit</code> specifies that mouse pointer positions will be reported in the units we specify, through a <code>set_coords</code> call illustrated later.</p><p>Now let&#39;s load an image to draw into the canvas:</p><pre><code class="language-jlcon">julia&gt; image = testimage(&quot;lighthouse&quot;);</code></pre><p>Zoom and pan interactions all work through a <a href="reference.html#GtkReactive.ZoomRegion"><code>ZoomRegion</code></a> signal; let&#39;s create one for this image:</p><pre><code class="language-jlcon">julia&gt; zr = Signal(ZoomRegion(image))
Signal{GtkReactive.ZoomRegion{RoundingIntegers.RInt64}}(GtkReactive.ZoomRegion{RoundingIntegers.RInt64}(GtkReactive.XY{IntervalSets.ClosedInterval{RoundingIntegers.RInt64}}(1..768,1..512),GtkReactive.XY{IntervalSets.ClosedInterval{RoundingIntegers.RInt64}}(1..768,1..512)), nactions=0)</code></pre><p>The key thing to note here is that it has been created for the intervals <code>1..768</code> (corresponding to the width of the image) and <code>1..512</code> (the height of the image). Let&#39;s now create a <code>view</code> of the image as a Signal:</p><pre><code class="language-jlcon">julia&gt; imgsig = map(zr) do r
           cv = r.currentview   # extract the currently-selected region
           view(image, UnitRange{Int}(cv.y), UnitRange{Int}(cv.x))
       end;</code></pre><p><code>imgsig</code> will update any time <code>zr</code> is modified. We then define a <code>draw</code> method for the canvas that paints this selection to the canvas:</p><pre><code class="language-jlcon">julia&gt; redraw = draw(c, imgsig, zr) do cnvs, img, r
           copy!(cnvs, img)
           set_coords(cnvs, r)  # set the canvas coordinates to the selected region
       end
Signal{Void}(nothing, nactions=0)</code></pre><p>We won&#39;t need to do anything further with <code>redraw</code>, but by assigning it to a variable we ensure it won&#39;t be garbage-collected (if that happened, the canvas would stop updating when <code>imgsig</code> and/or <code>zr</code> update).</p><p>Now, let&#39;s see our image:</p><pre><code class="language-jlcon">julia&gt; showall(win);</code></pre><p><img src="assets/image1.png" alt="image1"/></p><p>We could <code>push!</code> values to <code>zr</code> and see the image update:</p><pre><code class="language-jlcon">julia&gt; push!(zr, (100:300, indices(image, 2)))</code></pre><p><img src="assets/image2.png" alt="image2"/></p><p>Note that julia arrays are indexed <code>[row, column]</code>, whereas some graphical objects will be displayed <code>(x, y)</code> where <code>x</code> corresponds to <code>column</code> and <code>y</code> corresponds to <code>row</code>.</p><p>More useful is to couple <code>zr</code> to mouse actions. Let&#39;s turn on both zooming and panning:</p><pre><code class="language-jlcon">julia&gt; srb = init_zoom_rubberband(c, zr)
Dict{String,Any} with 5 entries:
  &quot;drag&quot;    =&gt; Signal{Void}(nothing, nactions=0)
  &quot;init&quot;    =&gt; Signal{Void}(nothing, nactions=0)
  &quot;active&quot;  =&gt; Signal{Bool}(false, nactions=0)
  &quot;finish&quot;  =&gt; Signal{Void}(nothing, nactions=0)
  &quot;enabled&quot; =&gt; Signal{Bool}(true, nactions=0)

julia&gt; spand = init_pan_drag(c, zr)
Dict{String,Any} with 5 entries:
  &quot;drag&quot;    =&gt; Signal{Void}(nothing, nactions=0)
  &quot;init&quot;    =&gt; Signal{Void}(nothing, nactions=0)
  &quot;active&quot;  =&gt; Signal{Bool}(false, nactions=0)
  &quot;finish&quot;  =&gt; Signal{Void}(nothing, nactions=0)
  &quot;enabled&quot; =&gt; Signal{Bool}(true, nactions=0)</code></pre><p>Now hold down your <code>Ctrl</code> key on your keyboard, click on the image, and drag to select a region of interest. You should see the image zoom in on that region. Then try clicking your mouse (without holding <code>Ctrl</code>) and drag; the image will move around, following your mouse. Double-click on the image while holding down <code>Ctrl</code> to zoom out to full view.</p><p>The returned dictionaries have a number of signals necessary for internal operations. Perhaps the only important user-level element is <code>enabled</code>; if you <code>push!(srg[&quot;enabled&quot;], false)</code> then you can (temporarily) turn off rubber-band initiation.</p><p>If you have a wheel mouse, you can activate additional interactions with <code>init_zoom_scroll</code> and <code>init_pan_scroll</code>.</p><footer><hr/><a class="next" href="reference.html"><span class="direction">Next</span><span class="title">Reference</span></a></footer></article></body></html>

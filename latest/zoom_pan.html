<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Zoom and pan · GtkReactive</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="../versions.js"></script></head><body><nav class="toc"><h1>GtkReactive</h1><form class="search" action="search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li><a class="toctext" href="controls.html">A first example: GUI controls</a></li><li><a class="toctext" href="drawing.html">A simple drawing program</a></li><li class="current"><a class="toctext" href="zoom_pan.html">Zoom and pan</a><ul class="internal"></ul></li><li><a class="toctext" href="reference.html">Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="zoom_pan.html">Zoom and pan</a></li></ul><a class="edit-page" href="https://github.com/JuliaGizmos/GtkReactive.jl/tree/f9663bc89708439d4649831c49eac23a04691c91/docs/src/zoom_pan.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Zoom-and-pan-1" href="#Zoom-and-pan-1">Zoom and pan</a></h1><p>In addition to low-level canvas support, GtkReactive also provides high-level functions to make it easier implement rubber-banding, pan, and zoom functionality.</p><p>To illustrate these tools, let&#39;s first open a window with a drawing canvas:</p><pre><code class="language-jlcon">julia&gt; using Gtk.ShortNames, GtkReactive, TestImages

julia&gt; win = Window(&quot;Image&quot;);

julia&gt; c = canvas(UserUnit);

julia&gt; push!(win, c);</code></pre><p>As explained in <a href="drawing.html#A-simple-drawing-program-1">A simple drawing program</a>, the <code>UserUnit</code> specifies that mouse pointer positions will be reported in the units we specify, through a <code>set_coords</code> call below.</p><p>Now let&#39;s load an image to draw into the canvas:</p><pre><code class="language-jlcon">julia&gt; image = testimage(&quot;lighthouse&quot;);</code></pre><p>For what follows, it may be worth reminding readers that julia arrays are indexed as <code>image[row, column]</code>, whereas for graphics we usually think in terms of <code>(x, y)</code>. Since <code>x</code> corresponds to <code>column</code> and <code>y</code> corresponds to <code>row</code>, some operations will require that we swap the first and second indices.</p><p>Zoom and pan interactions all work through a <a href="reference.html#GtkReactive.ZoomRegion"><code>ZoomRegion</code></a> signal; let&#39;s create one for this image:</p><pre><code class="language-jlcon">julia&gt; zr = Signal(ZoomRegion(image))
Signal{GtkReactive.ZoomRegion{RoundingIntegers.RInt64}}(GtkReactive.ZoomRegion{RoundingIntegers.RInt64}(GtkReactive.XY{IntervalSets.ClosedInterval{RoundingIntegers.RInt64}}(1..768,1..512),GtkReactive.XY{IntervalSets.ClosedInterval{RoundingIntegers.RInt64}}(1..768,1..512)), nactions=0)</code></pre><p>The key thing to note here is that it has been created for the intervals <code>1..768</code> (corresponding to the width of the image) and <code>1..512</code> (the height of the image). Let&#39;s now create a <code>view</code> of the image as a Signal:</p><pre><code class="language-jlcon">julia&gt; imgsig = map(zr) do r
           cv = r.currentview   # extract the currently-selected region
           view(image, UnitRange{Int}(cv.y), UnitRange{Int}(cv.x))
       end;</code></pre><p><code>imgsig</code> will update any time <code>zr</code> is modified. We then define a <code>draw</code> method for the canvas that paints this selection to the canvas:</p><pre><code class="language-jlcon">julia&gt; redraw = draw(c, imgsig, zr) do cnvs, img, r
           copy!(cnvs, img)
           set_coords(cnvs, r)  # set the canvas coordinates to the selected region
       end
Signal{Void}(nothing, nactions=0)</code></pre><p>We won&#39;t need to do anything further with <code>redraw</code>, but as a reminder: by assigning it to a variable we ensure it won&#39;t be garbage-collected (if that happened, the canvas would stop updating when <code>imgsig</code> and/or <code>zr</code> update).</p><p>Now, let&#39;s see our image:</p><pre><code class="language-jlcon">julia&gt; showall(win);</code></pre><p><img src="assets/image1.png" alt="image1"/></p><p>We could <code>push!</code> values to <code>zr</code> and see the image update:</p><pre><code class="language-jlcon">julia&gt; push!(zr, (100:300, indices(image, 2)))</code></pre><p><img src="assets/image2.png" alt="image2"/></p><p>More useful is to couple <code>zr</code> to mouse actions. Let&#39;s turn on both zooming and panning:</p><pre><code class="language-jlcon">julia&gt; rb = init_zoom_rubberband(c, zr)
Dict{String,Any} with 5 entries:
  &quot;drag&quot;    =&gt; Signal{Void}(nothing, nactions=0)
  &quot;init&quot;    =&gt; Signal{Void}(nothing, nactions=0)
  &quot;active&quot;  =&gt; Signal{Bool}(false, nactions=0)
  &quot;finish&quot;  =&gt; Signal{Void}(nothing, nactions=0)
  &quot;enabled&quot; =&gt; Signal{Bool}(true, nactions=0)

julia&gt; pandrag = init_pan_drag(c, zr)
Dict{String,Any} with 5 entries:
  &quot;drag&quot;    =&gt; Signal{Void}(nothing, nactions=0)
  &quot;init&quot;    =&gt; Signal{Void}(nothing, nactions=0)
  &quot;active&quot;  =&gt; Signal{Bool}(false, nactions=0)
  &quot;finish&quot;  =&gt; Signal{Void}(nothing, nactions=0)
  &quot;enabled&quot; =&gt; Signal{Bool}(true, nactions=0)</code></pre><p>Now hold down your <code>Ctrl</code> key on your keyboard, click on the image, and drag to select a region of interest. You should see the image zoom in on that region. Then try clicking your mouse (without holding <code>Ctrl</code>) and drag; the image will move around, following your mouse. Double-click on the image while holding down <code>Ctrl</code> to zoom out to full view.</p><p>The returned dictionaries have a number of signals necessary for internal operations. Perhaps the only important user-level element is <code>enabled</code>; if you <code>push!(rb[&quot;enabled&quot;], false)</code> then you can (temporarily) turn off rubber-band initiation.</p><p>If you have a wheel mouse, you can activate additional interactions with <code>init_zoom_scroll</code> and <code>init_pan_scroll</code>.</p><footer><hr/><a class="previous" href="drawing.html"><span class="direction">Previous</span><span class="title">A simple drawing program</span></a><a class="next" href="reference.html"><span class="direction">Next</span><span class="title">Reference</span></a></footer></article></body></html>
